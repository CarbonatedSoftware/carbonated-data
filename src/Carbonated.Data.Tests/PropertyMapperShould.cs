using System;
using System.Linq;
using NUnit.Framework;
using static Carbonated.Data.Tests.SharedMethods;

namespace Carbonated.Data.Tests
{
    [TestFixture]
    public class PropertyMapperShould
    {
        [Test]
        public void GenerateDefaultPropertyMappingsForWritableProperties()
        {
            var mapper = new PropertyMapper<Entity>();

            CollectionAssert.AreEqual(Strings("Id", "Name", "Title"), mapper.Mappings.Select(m => m.Field));
        }

        [Test]
        public void OverrideDefaultMappingsWithExplicitMappings()
        {
            var mapper = new PropertyMapper<Entity>()
                .Map(x => x.Name, "nom");

            var fields = mapper.Mappings.Select(m => m.Field);
            CollectionAssert.DoesNotContain(fields, "Name");
            CollectionAssert.Contains(fields, "nom");
        }

        [Test]
        public void ThrowExceptionWhenFieldIsMappedToMoreThanOneProperty()
        {
            var mapper = new PropertyMapper<Entity>();

            var ex = Assert.Throws<MappingException>(() => mapper.Map(x => x.Name, "Title"));
            StringAssert.StartsWith("Field cannot be mapped to more than one property", ex.Message);
        }

        [Test]
        public void DefaultGeneratedMappingsToOptional()
        {
            var mapper = new PropertyMapper<Entity>();

            Assert.IsTrue(mapper.Mappings.All(m => m.Condition == PopulationCondition.Optional));
        }

        [Test]
        public void OverrideDefaultConditionsWithTypeCondition()
        {
            var mapper = new PropertyMapper<Entity>(PopulationCondition.Required);

            Assert.IsTrue(mapper.Mappings.All(m => m.Condition == PopulationCondition.Required));
        }

        [Test]
        public void MarkPropertyAsIgnoredWhenIgnored()
        {
            var mapper = new PropertyMapper<Entity>()
                .Ignore(x => x.Title);

            Assert.IsTrue(mapper.Mappings.Single(m => m.Property.Name == "Title").IsIgnored);
        }

        [Test]
        public void OverrideTypeConditionWithPropertyConditions()
        {
            var mapper = new PropertyMapper<Entity>(PopulationCondition.Required)
                .MapNotNull(x => x.Id, "id")
                .MapOptional(x => x.Name, "name")
                .Optional(x => x.Title);

            var idMap = mapper.Mappings.Single(m => m.Property.Name == "Id");
            var nameMap = mapper.Mappings.Single(m => m.Property.Name == "Name");
            var titleMap = mapper.Mappings.Single(m => m.Property.Name == "Title");

            Assert.AreEqual(PopulationCondition.NotNull, idMap.Condition);
            Assert.AreEqual(PopulationCondition.Optional, nameMap.Condition);
            Assert.AreEqual(PopulationCondition.Optional, titleMap.Condition);
        }

        [Test]
        public void KeepTypeConditionWhenNonConditionalMapIsCalled()
        {
            var mapper = new PropertyMapper<Entity>(PopulationCondition.Required)
                .Map(x => x.Name, "nom");

            Assert.AreEqual(PopulationCondition.Required, mapper.Mappings.Single(m => m.Property.Name == "Name").Condition);
        }

        [Test]
        public void SetCustomValueConverterWhenSpecified()
        {
            Func<object, object> customConverter = value => int.Parse(value.ToString());

            var mapper = new PropertyMapper<Entity>()
                .Map(x => x.Id, "id", customConverter);

            Assert.AreSame(customConverter, mapper.Mappings.Single(m => m.Property.Name == "Id").ValueConverter);
        }

        [Test]
        public void SetAfterBindingActionForEntityWhenSpecified()
        {
            Action<Record, Entity> action = (record, entity) => entity.Name = "name";

            var mapper = new PropertyMapper<Entity>()
                .AfterBinding(action);

            Assert.AreSame(action, mapper.AfterBindAction);
        }

        #region Instance activation and population

        [Test]
        public void PopulateFromAutoGeneratedMapping()
        {
            var record = Record(("id", 10), ("name", "John Q"), ("title", "Tester"));

            var mapper = new PropertyMapper<Entity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", "Tester"), inst);
        }

        [Test]
        public void PopulateFromCustomMapping()
        {
            var record = Record(("id", 10), ("nom", "John Q"), ("role", "Tester"));

            var mapper = new PropertyMapper<Entity>()
                .Map(x => x.Name, "nom")
                .Map(x => x.Title, "role");
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", "Tester"), inst);
        }

        [Test]
        public void PopulateFromCustomMappingWithValueConverter()
        {
            var record = Record(("id", "ten"), ("name", "John Q"), ("title", "Tester"));

            var mapper = new PropertyMapper<Entity>()
                .Map(x => x.Id, "id", v => v.ToString() == "ten" ? 10 : 0);
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", "Tester"), inst);
        }

        [Test]
        public void CallAfterBindActionWhenSet()
        {
            var record = Record(("id", 10), ("name", "John Q"), ("title", "Tester"));

            var mapper = new PropertyMapper<Entity>()
                .AfterBinding((r, e) => e.Title = "override");
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", "override"), inst);
        }

        [Test]
        public void NotLoadFromRecordWhenPropertyIsMarkedIgnore()
        {
            var record = Record(("id", 10), ("name", "John Q"), ("title", "Tester"));

            var mapper = new PropertyMapper<Entity>()
                .Ignore(x => x.Title);
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", null), inst);
        }

        [Test]
        public void PopulateWhenRecordHasNonNormalName()
        {
            var record = Record(("id", 10), ("name", "John Q"), ("ti_tle", "Tester"));

            var mapper = new PropertyMapper<Entity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(new Entity(10, "John Q", "Tester"), inst);
        }

        [Test]
        public void PopulateWhenPropertyHasNonNormalName()
        {
            var record = Record(("EntityId", 50));

            var mapper = new PropertyMapper<NonNormalEntity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(50, inst.Entity_Id);
        }

        [Test]
        public void ConvertNullsToDefaultForValueTypes()
        {
            var record = Record(("intprop", null), ("dateprop", DBNull.Value));

            var mapper = new PropertyMapper<IntDate>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(0, inst.IntProp);
            Assert.AreEqual(DateTime.MinValue, inst.DateProp);
        }

        [Test]
        public void SetNullForNullableValueTypes()
        {
            var record = Record(("intprop", null), ("dateprop", DBNull.Value));

            var mapper = new PropertyMapper<NullableIntDate>();
            var inst = mapper.CreateInstance(record);

            Assert.IsNull(inst.IntProp);
            Assert.IsNull(inst.DateProp);
        }

        [Test]
        public void ConvertEnums()
        {
            var record = Record(("color", "Blue"), ("shape", 2), ("othercolor", DBNull.Value), ("othershape", ""));

            var mapper = new PropertyMapper<Enums>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(Enums.Colors.Blue, inst.Color);
            Assert.AreEqual(Enums.Shapes.Square, inst.Shape);
            Assert.AreEqual(Enums.Colors.Red, inst.OtherColor);
            Assert.AreEqual(Enums.Shapes.Circle, inst.OtherShape);
        }

        [Test]
        public void ThrowWhenRecordHasUndefinedEnumValue()
        {
            var record1 = Record(("color", "Yellow"));
            var record2 = Record(("shape", 5));

            var mapper = new PropertyMapper<Enums>();

            Assert.Throws<BindingException>(() => mapper.CreateInstance(record1));
            Assert.Throws<BindingException>(() => mapper.CreateInstance(record2));
        }

        [Test]
        public void ConvertGuids()
        {
            var record = Record(("foo", null), ("bar", DBNull.Value), ("baz", "10DB5BD9-A8CC-46E2-A5EB-791460B0B1CC"));

            var mapper = new PropertyMapper<GuidEntity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(Guid.Empty, inst.Foo);
            Assert.AreEqual(Guid.Empty, inst.Bar);
            Assert.AreEqual(new Guid("10DB5BD9-A8CC-46E2-A5EB-791460B0B1CC"), inst.Baz);
        }

        [Test]
        public void ConvertNullableGuids()
        {
            var record = Record(("foo", null), ("bar", string.Empty), ("baz", "10DB5BD9-A8CC-46E2-A5EB-791460B0B1CC"));

            var mapper = new PropertyMapper<NullableGuidEntity>();
            var inst = mapper.CreateInstance(record);

            Assert.IsNull(inst.Foo);
            Assert.IsNull(inst.Bar);
            Assert.AreEqual(new Guid("10DB5BD9-A8CC-46E2-A5EB-791460B0B1CC"), inst.Baz);
        }

        [Test]
        public void ThrowWhenRecordHasInvalidGuidValue()
        {
            var record = Record(("foo", "bogusguid"));

            var mapper = new PropertyMapper<GuidEntity>();

            Assert.Throws<BindingException>(() => mapper.CreateInstance(record));
        }

        [Test]
        public void ConvertEmptyCharColumnsIntoDefaultForCharType()
        {
            var record = Record(("CharProp", string.Empty));

            var mapper = new PropertyMapper<CharEntity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(default(char), inst.CharProp);
        }

        [Test]
        public void ConvertValueTypesStoredAsStringsInTheRecord()
        {
            var record = Record(("intprop", "42"), ("dateprop", "2018-04-02 08:30:01"), ("decimalprop", "3.14"));

            var mapper = new PropertyMapper<ValueEntity>();
            var inst = mapper.CreateInstance(record);

            Assert.AreEqual(42, inst.IntProp);
            Assert.AreEqual(new DateTime(2018, 4, 2, 8, 30, 1), inst.DateProp);
            Assert.AreEqual(3.14m, inst.DecimalProp);
        }

        // deserialize json for complex properties when field is string

        // deserialize json for complex properties for arrays

        // deserialize json for complex properties for arrays when empty

        // deserialize json for complex properties for arrays when value is null

        // throw when required property has missing field

        // throw when not null property is null

        #endregion

        #region Test types

        class NonNormalEntity
        {
            public int Entity_Id { get; set; }
        }

        class IntDate
        {
            public int IntProp { get; set; }
            public DateTime DateProp { get; set; }
        }

        class NullableIntDate
        {
            public int? IntProp { get; set; }
            public DateTime? DateProp { get; set; }
        }

        class Enums
        {
            public enum Colors { Red, Blue, Green }
            public enum Shapes { Circle, Triangle, Square }

            public Colors Color { get; set; }
            public Shapes Shape { get; set; }
            public Colors OtherColor { get; set; }
            public Shapes OtherShape { get; set; }
        }

        class GuidEntity
        {
            public Guid Foo { get; set; }
            public Guid Bar { get; set; }
            public Guid Baz { get; set; }
        }

        class NullableGuidEntity
        {
            public Guid? Foo { get; set; }
            public Guid? Bar { get; set; }
            public Guid? Baz { get; set; }
        }

        class CharEntity
        {
            public char CharProp { get; set; }
        }

        class ValueEntity
        {
            public int IntProp { get; set; }
            public DateTime DateProp { get; set; }
            public decimal DecimalProp { get; set; }
        }

        #endregion
    }
}
